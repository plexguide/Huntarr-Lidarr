#!/usr/bin/env bash

# ---------------------------
# Configuration
# ---------------------------
# Use environment variables if provided; otherwise, fall back to defaults.
API_KEY=${API_KEY:-"your-api-key"}
API_URL=${API_URL:-"http://your-lidarr-address:8686"}

# How many items (artists or songs) to process before restarting the search cycle
# Keep this number to 1 or lower if utilizing [artist] mode - queries more songs as a result
MAX_ITEMS=${MAX_ITEMS:-10}

# Sleep duration in seconds after processing an item (900=15min)
SLEEP_DURATION=${SLEEP_DURATION:-900}

# Set to true to pick items randomly, false to go in order
RANDOM_SELECTION=${RANDOM_SELECTION:-true}

# If MONITORED_ONLY is set to true, only missing tracks from monitored artists are processed.
MONITORED_ONLY=${MONITORED_ONLY:-false}

# Modes:
#   "artist" - process incomplete artists as a whole (missing tracks).
#   "song"   - process individual missing tracks across all artists.
SEARCH_MODE=${SEARCH_MODE:-"song"}

# ---------------------------
# Helper Functions
# ---------------------------

get_artists_json() {
  curl -s -H "X-Api-Key: $API_KEY" "$API_URL/api/v1/artist"
}

get_albums_for_artist() {
  local artist_id="$1"
  curl -s -H "X-Api-Key: $API_KEY" "$API_URL/api/v1/album?artistId=$artist_id"
}

get_tracks_for_album() {
  local album_id="$1"
  curl -s -H "X-Api-Key: $API_KEY" "$API_URL/api/v1/track?albumId=$album_id"
}

refresh_artist() {
  local artist_id="$1"
  curl -s -X POST \
    -H "X-Api-Key: $API_KEY" \
    -H "Content-Type: application/json" \
    -d "{\"name\":\"RefreshArtist\",\"artistIds\":[$artist_id]}" \
    "$API_URL/api/v1/command"
}

missing_album_search() {
  local artist_id="$1"
  curl -s -X POST \
    -H "X-Api-Key: $API_KEY" \
    -H "Content-Type: application/json" \
    -d "{\"name\":\"MissingAlbumSearch\",\"artistIds\":[$artist_id]}" \
    "$API_URL/api/v1/command"
}

album_search() {
  local album_id="$1"
  curl -s -X POST \
    -H "X-Api-Key: $API_KEY" \
    -H "Content-Type: application/json" \
    -d "{\"name\":\"AlbumSearch\",\"albumIds\":[$album_id]}" \
    "$API_URL/api/v1/command"
}

# ---------------------------
# Main "Artist" Mode
# ---------------------------
process_artists_mode() {
  echo "=== Running in ARTIST MODE ==="

  # Fetch all artists
  ARTISTS_JSON=$(get_artists_json)
  if [ -z "$ARTISTS_JSON" ]; then
    echo "ERROR: Unable to retrieve artist data from Lidarr. Retrying in 60 seconds..."
    sleep 60
    return
  fi

  # Filter for incomplete artists (missing tracks)
  # If MONITORED_ONLY=true, also require .monitored == true
  if [ "$MONITORED_ONLY" = "true" ]; then
    echo "MONITORED_ONLY=true: filtering monitored artists with missing tracks..."
    INCOMPLETE_ARTISTS_JSON=$(echo "$ARTISTS_JSON" | \
      jq '[.[] | select(.monitored == true and .statistics.trackCount > .statistics.trackFileCount)]')
  else
    echo "MONITORED_ONLY=false: filtering all artists with missing tracks..."
    INCOMPLETE_ARTISTS_JSON=$(echo "$ARTISTS_JSON" | \
      jq '[.[] | select(.statistics.trackCount > .statistics.trackFileCount)]')
  fi

  TOTAL_INCOMPLETE=$(echo "$INCOMPLETE_ARTISTS_JSON" | jq 'length')
  if [ "$TOTAL_INCOMPLETE" -eq 0 ]; then
    echo "No artists with missing tracks found. Waiting 60 seconds..."
    sleep 60
    return
  fi

  echo "Found $TOTAL_INCOMPLETE incomplete artist(s)."
  echo "Using RANDOM_SELECTION=$RANDOM_SELECTION. Will process up to $MAX_ITEMS artist(s)."

  ARTISTS_PROCESSED=0
  ALREADY_CHECKED=()

  while true; do
    if [ "$MAX_ITEMS" -gt 0 ] && [ "$ARTISTS_PROCESSED" -ge "$MAX_ITEMS" ]; then
      echo "Reached MAX_ITEMS ($MAX_ITEMS). Breaking out."
      break
    fi

    if [ ${#ALREADY_CHECKED[@]} -ge "$TOTAL_INCOMPLETE" ]; then
      echo "All artists processed. Breaking out."
      break
    fi

    # Determine which artist index to pick next
    if [ "$RANDOM_SELECTION" = "true" ] && [ "$TOTAL_INCOMPLETE" -gt 1 ]; then
      while true; do
        INDEX=$((RANDOM % TOTAL_INCOMPLETE))
        if [[ ! " ${ALREADY_CHECKED[*]} " =~ " ${INDEX} " ]]; then
          break
        fi
      done
    else
      for ((i=0; i<TOTAL_INCOMPLETE; i++)); do
        if [[ ! " ${ALREADY_CHECKED[*]} " =~ " ${i} " ]]; then
          INDEX=$i
          break
        fi
      done
    fi

    ALREADY_CHECKED+=("$INDEX")

    ARTIST=$(echo "$INCOMPLETE_ARTISTS_JSON" | jq ".[$INDEX]")
    ARTIST_ID=$(echo "$ARTIST" | jq '.id')
    ARTIST_NAME=$(echo "$ARTIST" | jq -r '.artistName')
    TRACK_COUNT=$(echo "$ARTIST" | jq '.statistics.trackCount')
    TRACK_FILE_COUNT=$(echo "$ARTIST" | jq '.statistics.trackFileCount')
    MISSING=$((TRACK_COUNT - TRACK_FILE_COUNT))

    echo "Processing artist \"$ARTIST_NAME\" (ID: $ARTIST_ID) with $MISSING missing track(s)."

    # 1) Refresh the artist
    echo "Refreshing artist to ensure latest data..."
    REFRESH_RESP=$(refresh_artist "$ARTIST_ID")
    REFRESH_ID=$(echo "$REFRESH_RESP" | jq '.id // empty')
    if [ -z "$REFRESH_ID" ]; then
      echo "WARNING: Could not refresh artist $ARTIST_NAME. Skipping."
      sleep 10
      continue
    fi

    echo "Refresh command accepted (ID: $REFRESH_ID). Waiting 5s..."
    sleep 5

    # 2) MissingAlbumSearch
    echo "Searching for missing albums/tracks for \"$ARTIST_NAME\"..."
    SEARCH_RESP=$(missing_album_search "$ARTIST_ID")
    SEARCH_ID=$(echo "$SEARCH_RESP" | jq '.id // empty')
    if [ -n "$SEARCH_ID" ]; then
      echo "Search command accepted (ID: $SEARCH_ID)."
    else
      echo "WARNING: MissingAlbumSearch command failed for $ARTIST_NAME. Trying fallback 'AlbumSearch'..."
      # Fallback example: Just call "AlbumSearch" with the same artist ID array
      FALLBACK_SEARCH=$(curl -s -X POST \
        -H "X-Api-Key: $API_KEY" \
        -H "Content-Type: application/json" \
        -d "{\"name\":\"AlbumSearch\",\"artistIds\":[$ARTIST_ID]}" \
        "$API_URL/api/v1/command")
      FALLBACK_ID=$(echo "$FALLBACK_SEARCH" | jq '.id // empty')
      [ -n "$FALLBACK_ID" ] && echo "Fallback search accepted (ID: $FALLBACK_ID)."
    fi

    ARTISTS_PROCESSED=$((ARTISTS_PROCESSED + 1))
    echo "Artist processed. Sleeping for $SLEEP_DURATION seconds..."
    sleep "$SLEEP_DURATION"
  done
}

# ---------------------------
# Main "Song" Mode
# ---------------------------
process_songs_mode() {
  echo "=== Running in SONG MODE ==="
  # We gather all missing tracks from all (relevant) artists, then process them individually

  ARTISTS_JSON=$(get_artists_json)
  if [ -z "$ARTISTS_JSON" ]; then
    echo "ERROR: Unable to retrieve artist data from Lidarr. Retrying in 60 seconds..."
    sleep 60
    return
  fi

  # Build an array of missing track objects: { artistId, albumId, trackId, trackTitle, artistName, albumTitle, ... }
  MISSING_TRACKS=()

  # Parse each artist
  MAPFILE_ARTISTS=$(echo "$ARTISTS_JSON" | jq -c '.[]')
  while read -r ARTIST; do
    [ -z "$ARTIST" ] && continue

    ARTIST_ID=$(echo "$ARTIST" | jq '.id')
    ARTIST_NAME=$(echo "$ARTIST" | jq -r '.artistName')
    ARTIST_MONITORED=$(echo "$ARTIST" | jq -r '.monitored')
    TRACK_COUNT=$(echo "$ARTIST" | jq '.statistics.trackCount')
    TRACK_FILE_COUNT=$(echo "$ARTIST" | jq '.statistics.trackFileCount')

    if [ "$MONITORED_ONLY" = "true" ] && [ "$ARTIST_MONITORED" != "true" ]; then
      # Skip unmonitored
      continue
    fi

    # If there's no missing tracks, skip
    if [ $((TRACK_COUNT - TRACK_FILE_COUNT)) -le 0 ]; then
      continue
    fi

    # Now get the albums for this artist
    ALBUMS_JSON=$(get_albums_for_artist "$ARTIST_ID")
    [ -z "$ALBUMS_JSON" ] && continue

    MAPFILE_ALBUMS=$(echo "$ALBUMS_JSON" | jq -c '.[]')
    while read -r ALBUM; do
      [ -z "$ALBUM" ] && continue

      ALBUM_ID=$(echo "$ALBUM" | jq '.id')
      ALBUM_TITLE=$(echo "$ALBUM" | jq -r '.title')
      ALBUM_MONITORED=$(echo "$ALBUM" | jq -r '.monitored')

      # If MONITORED_ONLY, also skip unmonitored albums
      if [ "$MONITORED_ONLY" = "true" ] && [ "$ALBUM_MONITORED" != "true" ]; then
        continue
      fi

      # Get tracks for this album
      TRACKS_JSON=$(get_tracks_for_album "$ALBUM_ID")
      [ -z "$TRACKS_JSON" ] && continue

      MAPFILE_TRACKS=$(echo "$TRACKS_JSON" | jq -c '.[]')
      while read -r TRACK; do
        [ -z "$TRACK" ] && continue
        HAS_FILE=$(echo "$TRACK" | jq -r '.hasFile')
        TRACK_MONITORED=$(echo "$TRACK" | jq -r '.monitored')
        TRACK_ID=$(echo "$TRACK" | jq '.id')
        TRACK_TITLE=$(echo "$TRACK" | jq -r '.title')

        if [ "$HAS_FILE" = "false" ]; then
          # If MONITORED_ONLY, also skip unmonitored tracks
          if [ "$MONITORED_ONLY" = "true" ] && [ "$TRACK_MONITORED" != "true" ]; then
            continue
          fi

          # We have a missing track, store in array
          MISSING_TRACKS+=("{\"artistId\":$ARTIST_ID,\"albumId\":$ALBUM_ID,\"trackId\":$TRACK_ID,\"artistName\":\"$ARTIST_NAME\",\"albumTitle\":\"$ALBUM_TITLE\",\"trackTitle\":\"$TRACK_TITLE\"}")
        fi
      done <<< "$MAPFILE_TRACKS"
    done <<< "$MAPFILE_ALBUMS"
  done <<< "$MAPFILE_ARTISTS"

  TOTAL_MISSING_TRACKS=${#MISSING_TRACKS[@]}
  if [ "$TOTAL_MISSING_TRACKS" -eq 0 ]; then
    echo "No missing tracks found in SONG MODE. Waiting 60 seconds..."
    sleep 60
    return
  fi

  echo "Found $TOTAL_MISSING_TRACKS missing track(s)."
  echo "Using RANDOM_SELECTION=$RANDOM_SELECTION. Will process up to $MAX_ITEMS track(s)."

  TRACKS_PROCESSED=0
  ALREADY_CHECKED=()

  # We treat MISSING_TRACKS like an indexed array
  while true; do
    # Check max items
    if [ "$MAX_ITEMS" -gt 0 ] && [ "$TRACKS_PROCESSED" -ge "$MAX_ITEMS" ]; then
      echo "Reached MAX_ITEMS ($MAX_ITEMS). Breaking out."
      break
    fi

    if [ ${#ALREADY_CHECKED[@]} -ge "$TOTAL_MISSING_TRACKS" ]; then
      echo "All missing tracks processed. Breaking out."
      break
    fi

    # Pick random or next index
    if [ "$RANDOM_SELECTION" = "true" ] && [ "$TOTAL_MISSING_TRACKS" -gt 1 ]; then
      while true; do
        INDEX=$((RANDOM % TOTAL_MISSING_TRACKS))
        if [[ ! " ${ALREADY_CHECKED[*]} " =~ " ${INDEX} " ]]; then
          break
        fi
      done
    else
      for ((i=0; i<TOTAL_MISSING_TRACKS; i++)); do
        if [[ ! " ${ALREADY_CHECKED[*]} " =~ " ${i} " ]]; then
          INDEX=$i
          break
        fi
      done
    fi

    ALREADY_CHECKED+=("$INDEX")

    TRACK_OBJ="${MISSING_TRACKS[$INDEX]}"
    # Parse the JSON we stored
    ARTIST_ID=$(echo "$TRACK_OBJ" | jq -r '.artistId')
    ALBUM_ID=$(echo "$TRACK_OBJ" | jq -r '.albumId')
    TRACK_ID=$(echo "$TRACK_OBJ" | jq -r '.trackId')
    ARTIST_NAME=$(echo "$TRACK_OBJ" | jq -r '.artistName')
    ALBUM_TITLE=$(echo "$TRACK_OBJ" | jq -r '.albumTitle')
    TRACK_TITLE=$(echo "$TRACK_OBJ" | jq -r '.trackTitle')

    echo "Processing track \"$TRACK_TITLE\" from album \"$ALBUM_TITLE\" by \"$ARTIST_NAME\"..."

    # 1) Refresh the artist
    echo "Refreshing artist ($ARTIST_ID) to ensure latest data..."
    REFRESH_RESP=$(refresh_artist "$ARTIST_ID")
    REFRESH_ID=$(echo "$REFRESH_RESP" | jq '.id // empty')
    if [ -z "$REFRESH_ID" ]; then
      echo "WARNING: Could not refresh artist $ARTIST_NAME. Skipping track."
      sleep 10
      continue
    fi

    echo "Refresh command accepted (ID: $REFRESH_ID). Waiting 5s..."
    sleep 5

    # 2) Run an AlbumSearch for the album containing this track
    echo "Performing album search for \"$ALBUM_TITLE\" (albumId=$ALBUM_ID)..."
    SEARCH_RESP=$(album_search "$ALBUM_ID")
    SEARCH_ID=$(echo "$SEARCH_RESP" | jq '.id // empty')

    if [ -n "$SEARCH_ID" ]; then
      echo "AlbumSearch command accepted (ID: $SEARCH_ID)."
    else
      echo "WARNING: AlbumSearch command failed for album $ALBUM_TITLE. Response:"
      echo "$SEARCH_RESP"
    fi

    TRACKS_PROCESSED=$((TRACKS_PROCESSED + 1))
    echo "Track processed. Sleeping for $SLEEP_DURATION seconds..."
    sleep "$SLEEP_DURATION"
  done
}

# ---------------------------
# Main Loop
# ---------------------------
while true; do
  if [ "$SEARCH_MODE" = "song" ]; then
    process_songs_mode
  else
    process_artists_mode
  fi

  # If nothing got processed, we wait a bit
  echo "Cycle complete. Waiting 60s before next cycle..."
  sleep 60
done
